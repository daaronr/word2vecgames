<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Bocce</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 900px;
            width: 100%;
            padding: 40px;
        }

        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .screen {
            display: none;
        }

        .screen.active {
            display: block;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #333;
            font-weight: 600;
        }

        input[type="text"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
        }

        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.3s, transform 0.1s;
            width: 100%;
            margin-top: 10px;
        }

        button:hover {
            background: #5568d3;
        }

        button:active {
            transform: scale(0.98);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .game-header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            color: white;
        }

        .word-display {
            font-size: 1.5em;
            margin: 10px 0;
        }

        .word-label {
            font-size: 0.9em;
            opacity: 0.9;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .cards-section {
            margin: 30px 0;
        }

        .cards-section h3 {
            margin-bottom: 15px;
            color: #333;
        }

        .cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .card {
            background: white;
            border: 3px solid #e0e0e0;
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }

        .card:hover {
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
        }

        .card.selected {
            border: 4px solid #667eea !important;
            background: linear-gradient(135deg, #e0e7ff 0%, #c7d2fe 100%) !important;
            box-shadow: 0 6px 24px rgba(102, 126, 234, 0.6) !important;
            transform: scale(1.08);
        }

        .card.selected::before {
            content: '✓ SELECTED';
            position: absolute;
            top: -12px;
            left: 50%;
            transform: translateX(-50%);
            background: #667eea;
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.75em;
            font-weight: 700;
            white-space: nowrap;
        }

        /* Highlight cards with MINUS selected in red */
        .card.selected-minus {
            border: 4px solid #dc2626 !important;
            background: linear-gradient(135deg, #fee2e2 0%, #fca5a5 100%) !important;
            box-shadow: 0 6px 24px rgba(220, 38, 38, 0.7) !important;
            transform: scale(1.08);
        }

        .card.selected-minus::before {
            content: '✓ SUBTRACT';
            position: absolute;
            top: -12px;
            left: 50%;
            transform: translateX(-50%);
            background: #dc2626;
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.75em;
            font-weight: 700;
            white-space: nowrap;
        }

        .card-token {
            font-size: 1.1em;
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
        }

        .card-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        .sign-btn {
            background: #e0e0e0;
            color: #333;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            width: auto;
            margin: 0;
        }

        .sign-btn.active {
            background: #667eea;
            color: white;
            font-weight: 700;
            transform: scale(1.1);
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.4);
        }

        /* Make minus button SUPER obvious when active */
        .sign-btn[data-sign="-"].active {
            background: #dc2626 !important;
            color: white !important;
            font-weight: 900 !important;
            transform: scale(1.2) !important;
            box-shadow: 0 4px 12px rgba(220, 38, 38, 0.6) !important;
            border: 3px solid #991b1b !important;
            animation: pulse-minus 1.5s infinite;
        }

        @keyframes pulse-minus {
            0%, 100% {
                box-shadow: 0 4px 12px rgba(220, 38, 38, 0.6);
            }
            50% {
                box-shadow: 0 4px 20px rgba(220, 38, 38, 0.9);
            }
        }

        .joker-input {
            margin-top: 10px;
            padding: 8px;
            border: 2px solid #667eea;
            border-radius: 6px;
            width: 100%;
            font-size: 14px;
        }

        .timer {
            text-align: center;
            font-size: 1.5em;
            margin: 20px 0;
            color: #667eea;
            font-weight: 600;
        }

        .leaderboard {
            margin-top: 30px;
        }

        .leaderboard table {
            width: 100%;
            border-collapse: collapse;
        }

        .leaderboard th,
        .leaderboard td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #e0e0e0;
        }

        .leaderboard th {
            background: #f8f9fa;
            font-weight: 600;
            color: #333;
        }

        .leaderboard tr:hover {
            background: #f8f9fa;
        }

        .rank-1 {
            background: #fff9e6;
        }

        .status-message {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
        }

        .status-info {
            background: #e3f2fd;
            color: #1565c0;
        }

        .status-success {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .status-error {
            background: #ffebee;
            color: #c62828;
        }

        /* Visualization Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 20px;
            padding: 30px;
            max-width: 800px;
            width: 90%;
            max-height: 90vh;
            overflow: auto;
            position: relative;
        }

        .modal-close {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 30px;
            cursor: pointer;
            color: #999;
            background: none;
            border: none;
            padding: 0;
            width: auto;
            margin: 0;
        }

        .modal-close:hover {
            color: #333;
        }

        .viz-canvas {
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            width: 100%;
            max-width: 700px;
            height: 500px;
            cursor: crosshair;
            display: block;
            margin: 20px auto;
        }

        .viz-controls {
            text-align: center;
            margin: 15px 0;
        }

        .viz-legend {
            margin-top: 20px;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 8px;
            font-size: 0.9em;
        }

        .viz-legend-item {
            display: inline-block;
            margin: 5px 15px;
        }

        .viz-legend-dot {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .btn-viz {
            background: #28a745;
            margin-top: 5px;
        }

        .btn-viz:hover {
            background: #218838;
        }

        .players-list {
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .players-list h3 {
            margin-bottom: 10px;
            color: #333;
        }

        .player-item {
            padding: 8px 0;
            color: #666;
        }

        .similarity-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: 600;
            font-size: 0.9em;
        }

        .sim-very-close { background: #4caf50; color: white; }
        .sim-warm { background: #ff9800; color: white; }
        .sim-lukewarm { background: #ffc107; color: #333; }
        .sim-cold { background: #2196f3; color: white; }
        .sim-ice-cold { background: #607d8b; color: white; }

        .match-info {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-family: monospace;
            font-size: 0.9em;
            color: #666;
        }

        .private-cards-grid {
            grid-template-columns: repeat(2, 1fr);
        }

        @media (max-width: 600px) {
            .container {
                padding: 20px;
            }

            h1 {
                font-size: 1.8em;
            }

            .cards-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🎯 Word Bocce</h1>

        <!-- Lobby Screen -->
        <div id="lobby-screen" class="screen active">
            <div class="status-message status-info" id="url-match-info" style="display: none;">
                <strong>🎯 Joining match from link...</strong>
            </div>

            <div class="form-group">
                <label for="player-name">Your Name</label>
                <input type="text" id="player-name" placeholder="Enter your name" />
            </div>

            <button onclick="quickPlay()" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); font-size: 1.2em; padding: 15px;">
                🎮 Quick Play
            </button>

            <div style="margin: 20px 0; text-align: center; color: #999; font-size: 0.9em;">
                <span>Quick Play creates a new match and gives you a shareable link</span>
            </div>

            <div style="margin: 30px 0; text-align: center; color: #999;">
                <span>— OR —</span>
            </div>

            <button onclick="createMatch()">Create Match & Get Link</button>

            <div style="margin: 30px 0; text-align: center; color: #999;">
                <span>— OR —</span>
            </div>

            <button onclick="showPuzzleMode()" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);">
                Puzzle Mode (Solo)
            </button>

            <div style="margin: 30px 0; text-align: center; color: #999;">
                <span>— OR —</span>
            </div>

            <div class="form-group">
                <label for="match-id">Match ID</label>
                <input type="text" id="match-id" placeholder="Enter match ID to join" />
            </div>

            <button onclick="joinMatch()" class="btn-secondary">Join by Match ID</button>
        </div>

        <!-- Waiting Screen -->
        <div id="waiting-screen" class="screen">
            <div class="status-message status-info">
                <strong>Waiting in Lobby</strong>
            </div>

            <div class="match-info">
                <div>Match ID: <strong id="waiting-match-id"></strong></div>
                <button onclick="copyShareLink()" style="margin-top: 10px; padding: 8px 16px;">
                    📋 Copy Invite Link
                </button>
            </div>

            <div class="players-list">
                <h3>Players</h3>
                <div id="waiting-players"></div>
            </div>

            <button onclick="startMatch()">Start Game</button>
            <button onclick="refreshLobby()" class="btn-secondary">Refresh</button>
        </div>

        <!-- Game Screen -->
        <div id="game-screen" class="screen">
            <div class="game-header">
                <div class="word-label">Start Word</div>
                <div class="word-display" id="start-word">—</div>
                <div class="word-label" style="margin-top: 15px;">Target Word</div>
                <div class="word-display" id="target-word">—</div>
            </div>

            <!-- Real-time Nearest Word Feedback -->
            <div id="nearest-word-feedback" style="display: none; background: linear-gradient(135deg, #f6d365 0%, #fda085 100%); padding: 20px; border-radius: 12px; margin: 20px 0; text-align: center; color: white;">
                <div style="font-size: 0.9em; opacity: 0.95; margin-bottom: 5px;">You reached:</div>
                <div style="font-size: 1.8em; font-weight: 700; margin: 5px 0;" id="nearest-word-display">—</div>
                <div style="font-size: 0.95em; opacity: 0.9; margin-top: 5px;">
                    Target similarity: <strong id="target-similarity-display">—</strong> |
                    Nearest similarity: <strong id="nearest-similarity-display">—</strong>
                </div>
            </div>

            <div class="timer" id="timer">Time: --</div>

            <div class="cards-section">
                <h3>Public Cards (choose one)</h3>
                <div class="cards-grid" id="public-cards"></div>
            </div>

            <div class="cards-section">
                <h3>Your Private Cards (choose one)</h3>
                <div class="cards-grid private-cards-grid" id="private-cards"></div>
            </div>

            <button onclick="submitMove()" id="submit-btn">Submit Move</button>
            <button onclick="refreshRound()" class="btn-secondary">Refresh</button>
        </div>

        <!-- Results Screen -->
        <div id="results-screen" class="screen">
            <div class="status-message status-success">
                <strong>Round Complete!</strong>
            </div>

            <div class="game-header">
                <div class="word-label">Start Word</div>
                <div class="word-display" id="results-start-word">—</div>
                <div class="word-label" style="margin-top: 15px;">Target Word</div>
                <div class="word-display" id="results-target-word">—</div>
            </div>

            <div class="leaderboard">
                <h3>Leaderboard</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Player</th>
                            <th>Similarity</th>
                            <th>Nearest Word Reached</th>
                            <th>Closeness</th>
                        </tr>
                    </thead>
                    <tbody id="leaderboard-body"></tbody>
                </table>
            </div>

            <button onclick="nextRound()">Next Round</button>
            <button onclick="visualizeRound()" class="btn-viz">Visualize Round</button>
        </div>
    </div>

    <!-- Visualization Modal -->
    <div id="viz-modal" class="modal">
        <div class="modal-content">
            <button class="modal-close" onclick="closeVisualization()">&times;</button>
            <h2 style="text-align: center; color: #667eea; margin-bottom: 20px;">Word Vector Visualization</h2>

            <div class="viz-controls">
                <p style="color: #666; margin-bottom: 15px;">
                    2D projection of word vectors in semantic space
                </p>
            </div>

            <canvas id="viz-canvas" class="viz-canvas" width="700" height="500"></canvas>

            <div class="viz-legend">
                <div class="viz-legend-item">
                    <span class="viz-legend-dot" style="background: #667eea;"></span>
                    <span>Start Word</span>
                </div>
                <div class="viz-legend-item">
                    <span class="viz-legend-dot" style="background: #e74c3c;"></span>
                    <span>Target Word</span>
                </div>
                <div class="viz-legend-item">
                    <span class="viz-legend-dot" style="background: #f39c12;"></span>
                    <span>Public Card</span>
                </div>
                <div class="viz-legend-item">
                    <span class="viz-legend-dot" style="background: #9b59b6;"></span>
                    <span>Private Card</span>
                </div>
                <div class="viz-legend-item">
                    <span class="viz-legend-dot" style="background: #2ecc71;"></span>
                    <span>Result Vector</span>
                </div>
                <div class="viz-legend-item">
                    <span class="viz-legend-dot" style="background: #f6d365; border: 2px solid #fda085;"></span>
                    <span>Nearest Word Reached</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Puzzle Mode Screens -->
    <!-- Puzzle Selection Screen -->
    <div id="puzzle-select-screen" class="screen">
        <h2 style="text-align: center; color: #667eea; margin-bottom: 20px;">Puzzle Mode</h2>
        <p style="text-align: center; color: #666; margin-bottom: 30px;">
            Solve word vector puzzles solo. Use the allowed cards to navigate from start to target!
        </p>

        <div style="margin-bottom: 20px;">
            <label>Filter by Difficulty:</label>
            <select id="puzzle-difficulty-filter" onchange="filterPuzzles()" style="width: 100%; padding: 10px; border-radius: 8px; border: 2px solid #e0e0e0; font-size: 16px;">
                <option value="">All</option>
                <option value="easy">Easy</option>
                <option value="medium">Medium</option>
                <option value="hard">Hard</option>
            </select>
        </div>

        <div id="puzzle-list" style="max-height: 400px; overflow-y: auto;">
            <!-- Puzzles will be loaded here -->
        </div>

        <button onclick="showScreen('lobby-screen')" class="btn-secondary" style="margin-top: 20px;">Back to Lobby</button>
    </div>

    <!-- Puzzle Play Screen -->
    <div id="puzzle-play-screen" class="screen">
        <div class="status-message status-info" style="margin-bottom: 20px;">
            <strong id="puzzle-name">Puzzle Name</strong><br>
            <span id="puzzle-description">Description</span><br>
            <span id="puzzle-difficulty-badge"></span>
        </div>

        <div class="game-header">
            <div class="word-label">Start Word</div>
            <div class="word-display" id="puzzle-start-word">—</div>
            <div class="word-label" style="margin-top: 15px;">Target Word</div>
            <div class="word-display" id="puzzle-target-word">—</div>
        </div>

        <div class="cards-section">
            <h3>Available Cards (choose two)</h3>
            <div class="cards-grid" id="puzzle-cards"></div>
        </div>

        <div style="margin: 20px 0; text-align: center;">
            <button onclick="showHint()" class="btn-secondary" style="width: auto; display: inline-block; margin-right: 10px;">
                💡 Show Hint
            </button>
            <span id="hint-display" style="color: #2d3748; font-style: italic; font-weight: 600; background: #fef3c7; padding: 8px 12px; border-radius: 6px; display: inline-block;"></span>
        </div>

        <button onclick="submitPuzzleSolution()" id="puzzle-submit-btn">Submit Solution</button>
        <button onclick="showScreen('puzzle-select-screen')" class="btn-secondary">Back to Puzzles</button>
    </div>

    <!-- Puzzle Result Screen -->
    <div id="puzzle-result-screen" class="screen">
        <div class="status-message status-success">
            <strong>Puzzle Complete!</strong>
        </div>

        <div style="text-align: center; margin: 30px 0;">
            <div id="stars-display" style="font-size: 3em; margin-bottom: 15px;">
                ⭐⭐⭐
            </div>
            <div style="font-size: 1.2em; color: #667eea; font-weight: 600; margin-bottom: 10px;">
                <span id="puzzle-result-similarity">0.75</span> similarity
            </div>
            <div style="color: #2d3748; font-size: 1.1em; margin-top: 8px;">
                <span style="color: #999;">You reached:</span> <strong style="color: #f59e0b; font-size: 1.3em;" id="puzzle-result-nearest">word</strong>
            </div>
        </div>

        <div style="background: #f5f5f5; padding: 20px; border-radius: 12px; margin: 20px 0;">
            <h3 style="margin-bottom: 15px; color: #333;">Your Solution</h3>
            <div style="font-family: monospace; font-size: 0.9em; color: #666;">
                <div><strong id="puzzle-result-start">start</strong></div>
                <div style="margin: 10px 0 10px 20px;">
                    <span id="puzzle-result-public-sign">+</span> <span id="puzzle-result-public">public</span><br>
                    <span id="puzzle-result-private-sign">+</span> <span id="puzzle-result-private">private</span>
                </div>
                <div>→ <strong id="puzzle-result-target">target</strong></div>
            </div>
        </div>

        <!-- Best Possible Move Section -->
        <div id="best-move-section" style="background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%); padding: 20px; border-radius: 12px; margin: 20px 0; border: 2px solid #81c784;">
            <h3 style="margin-bottom: 15px; color: #2e7d32; display: flex; align-items: center;">
                <span style="font-size: 1.3em; margin-right: 8px;">🏆</span> Best Possible Move
            </h3>
            <div id="best-move-content" style="font-family: monospace; font-size: 0.95em; color: #1b5e20;">
                <!-- Populated by JavaScript -->
            </div>
        </div>

        <!-- All Moves Comparison Section -->
        <div id="all-moves-section" style="background: #fafafa; padding: 20px; border-radius: 12px; margin: 20px 0; border: 1px solid #ddd;">
            <h3 style="margin-bottom: 15px; color: #333; display: flex; align-items: center;">
                <span style="font-size: 1.2em; margin-right: 8px;">📊</span> All Possible Moves
                <span style="font-size: 0.75em; margin-left: 10px; color: #999; font-weight: normal;">(top 20)</span>
            </h3>
            <div id="all-moves-content" style="max-height: 300px; overflow-y: auto;">
                <!-- Populated by JavaScript -->
            </div>
        </div>

        <!-- 2D Visualization Section -->
        <div id="visualization-section" style="background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); padding: 20px; border-radius: 12px; margin: 20px 0; border: 2px solid #64b5f6;">
            <h3 style="margin-bottom: 15px; color: #1565c0; display: flex; align-items: center;">
                <span style="font-size: 1.3em; margin-right: 8px;">🗺️</span> Word Space Map
                <span style="font-size: 0.75em; margin-left: 10px; color: #1976d2; font-weight: normal;">(2D projection)</span>
            </h3>
            <div style="text-align: center;">
                <canvas id="word-viz-canvas" width="900" height="600" style="background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); max-width: 100%;"></canvas>
            </div>

            <!-- Step-by-step explanation -->
            <div id="move-explanation" style="background: white; padding: 20px; border-radius: 8px; margin-top: 15px; border-left: 4px solid #667eea;">
                <h4 style="margin-top: 0; color: #667eea;">How Your Move Worked:</h4>
                <div id="explanation-text" style="color: #2d3748; line-height: 1.6;"></div>
                <div id="viz-legend" style="margin-top: 15px; font-size: 0.9em; color: #1565c0;">
                    <span style="margin: 0 8px;">🟢 Start</span>
                    <span style="margin: 0 8px;">🟣 Step 1</span>
                    <span style="margin: 0 8px;">🟠 Step 2</span>
                    <span style="margin: 0 8px;">🟡 Final Result</span>
                    <span style="margin: 0 8px;">🔴 Target</span>
                </div>
            </div>
        </div>

        <button onclick="nextPuzzle()">Next Puzzle</button>
        <button onclick="showScreen('puzzle-select-screen')" class="btn-secondary">Back to Puzzles</button>
    </div>

    <script>
        // Auto-detect API URL: use current origin when deployed, localhost for development
        const API_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
            ? 'http://localhost:8000'
            : window.location.origin;

        let state = {
            playerId: null,
            playerName: null,
            matchId: null,
            // Puzzle mode state
            currentPuzzle: null,
            allPuzzles: [],
            puzzleSelectedCards: { public: null, private: null },
            roundId: null,
            selectedPublic: null,
            selectedPublicSign: '+',
            selectedPrivate: null,
            selectedPrivateSign: '+',
            jokerToken: null,
            currentRound: null,
            timerInterval: null,
            privateCards: []
        };

        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
        }

        // Check URL for match ID on page load
        window.addEventListener('DOMContentLoaded', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const matchId = urlParams.get('match');

            if (matchId) {
                document.getElementById('url-match-info').style.display = 'block';
                document.getElementById('match-id').value = matchId;
                // Auto-join if name is provided
                const name = urlParams.get('name');
                if (name) {
                    document.getElementById('player-name').value = name;
                }
            }
        });

        async function quickPlay() {
            const name = document.getElementById('player-name').value.trim() ||
                         `Player${Math.floor(Math.random() * 1000)}`;

            document.getElementById('player-name').value = name;
            await createMatch();
        }

        async function createMatch() {
            const name = document.getElementById('player-name').value.trim();
            if (!name) {
                alert('Please enter your name');
                return;
            }

            state.playerName = name;

            try {
                const response = await fetch(`${API_URL}/match`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: `${name}'s match` })
                });

                if (!response.ok) {
                    const error = await response.json();
                    alert(`Error: ${error.detail}`);
                    return;
                }

                const match = await response.json();
                state.matchId = match.id;

                // Auto-join the match we just created
                await joinMatchById(state.matchId);

                // Show shareable link
                const shareUrl = `${window.location.origin}${window.location.pathname}?match=${state.matchId}`;
                setTimeout(() => {
                    const shareMsg = `🎯 Share this link with friends to join:\n\n${shareUrl}\n\nMatch ID: ${state.matchId}`;
                    if (navigator.clipboard && window.isSecureContext) {
                        navigator.clipboard.writeText(shareUrl).then(() => {
                            alert(`${shareMsg}\n\n✅ Link copied to clipboard!`);
                        }).catch(() => {
                            alert(shareMsg);
                        });
                    } else {
                        alert(shareMsg);
                    }
                }, 500);
            } catch (error) {
                alert(`Error: ${error.message}`);
            }
        }

        async function joinMatch() {
            const name = document.getElementById('player-name').value.trim();
            const matchId = document.getElementById('match-id').value.trim();

            if (!name) {
                alert('Please enter your name');
                return;
            }

            if (!matchId) {
                alert('Please enter a match ID');
                return;
            }

            state.playerName = name;
            state.matchId = matchId;

            await joinMatchById(matchId);
        }

        async function joinMatchById(matchId) {
            try {
                const response = await fetch(`${API_URL}/match/${matchId}/join`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ player_name: state.playerName })
                });

                if (!response.ok) {
                    const error = await response.json();
                    alert(`Error: ${error.detail}`);
                    return;
                }

                const data = await response.json();
                state.playerId = data.player.id;
                state.matchId = data.match.id;

                document.getElementById('waiting-match-id').textContent = state.matchId;

                updatePlayersList(data.match.players);
                showScreen('waiting-screen');
            } catch (error) {
                alert(`Error: ${error.message}`);
            }
        }

        function updatePlayersList(players) {
            const container = document.getElementById('waiting-players');
            const playersList = Object.values(players).map(p =>
                `<div class="player-item">${p.name}${p.id === state.playerId ? ' (You)' : ''}</div>`
            ).join('');
            container.innerHTML = playersList || '<div class="player-item">No players yet</div>';
        }

        async function refreshLobby() {
            if (!state.matchId) return;

            try {
                const response = await fetch(`${API_URL}/match/${state.matchId}/round/current`);
                if (response.ok) {
                    // Match has started!
                    const roundData = await response.json();
                    state.roundId = roundData.id;
                    state.currentRound = roundData;
                    displayRound(roundData);
                    showScreen('game-screen');
                }
            } catch (error) {
                // Still in lobby
            }
        }

        async function startMatch() {
            if (!state.matchId) return;

            try {
                const response = await fetch(`${API_URL}/match/${state.matchId}/start`, {
                    method: 'POST'
                });

                if (!response.ok) {
                    const error = await response.json();
                    alert(`Error: ${error.detail}`);
                    return;
                }

                const roundData = await response.json();
                state.roundId = roundData.id;
                state.currentRound = roundData;

                displayRound(roundData);
                showScreen('game-screen');
            } catch (error) {
                alert(`Error: ${error.message}`);
            }
        }

        function displayRound(roundData) {
            // Hide nearest word feedback from previous round
            document.getElementById('nearest-word-feedback').style.display = 'none';

            document.getElementById('start-word').textContent = roundData.start_word;
            document.getElementById('target-word').textContent = roundData.target_word;

            // Display public cards
            const publicContainer = document.getElementById('public-cards');
            publicContainer.innerHTML = roundData.public_cards.map((card, idx) => `
                <div class="card" onclick="selectPublicCard(${idx}, '${card.token}')">
                    <div class="card-token">${card.token}</div>
                    <div class="card-controls">
                        <button class="sign-btn ${state.selectedPublic === idx && state.selectedPublicSign === '+' ? 'active' : ''}"
                                onclick="event.stopPropagation(); setPublicSign(${idx}, '${card.token}', '+')">+</button>
                        <button class="sign-btn ${state.selectedPublic === idx && state.selectedPublicSign === '-' ? 'active' : ''}"
                                onclick="event.stopPropagation(); setPublicSign(${idx}, '${card.token}', '-')">−</button>
                    </div>
                </div>
            `).join('');

            // Get private cards for this player
            // We need to fetch the full match state to get private cards
            fetchPrivateCards();

            // Start timer
            startTimer(roundData.moves_deadline_ts);
        }

        async function fetchPrivateCards() {
            try {
                const response = await fetch(`${API_URL}/match/${state.matchId}/player/${state.playerId}`);
                const data = await response.json();

                const privateCards = data.player.private_cards || [];
                const privateContainer = document.getElementById('private-cards');

                if (privateCards.length === 0) {
                    privateContainer.innerHTML = `
                        <div class="status-message status-info">
                            No private cards dealt yet. Wait for the round to start.
                        </div>
                    `;
                    return;
                }

                privateContainer.innerHTML = privateCards.map((card, idx) => {
                    if (card.type === 'JOKER') {
                        return `
                            <div class="card" onclick="selectPrivateCard(${idx}, 'JOKER')">
                                <div class="card-token">🃏 JOKER</div>
                                <input type="text" class="joker-input" placeholder="Enter any word"
                                       id="joker-input-${idx}" onclick="event.stopPropagation()">
                                <div class="card-controls">
                                    <button class="sign-btn ${state.selectedPrivate === idx && state.selectedPrivateSign === '+' ? 'active' : ''}"
                                            onclick="event.stopPropagation(); setPrivateSign(${idx}, 'JOKER', '+')">+</button>
                                    <button class="sign-btn ${state.selectedPrivate === idx && state.selectedPrivateSign === '-' ? 'active' : ''}"
                                            onclick="event.stopPropagation(); setPrivateSign(${idx}, 'JOKER', '-')">−</button>
                                </div>
                            </div>
                        `;
                    }
                    return `
                        <div class="card" onclick="selectPrivateCard(${idx}, '${card.token}')">
                            <div class="card-token">${card.token}</div>
                            <div class="card-controls">
                                <button class="sign-btn ${state.selectedPrivate === idx && state.selectedPrivateSign === '+' ? 'active' : ''}"
                                        onclick="event.stopPropagation(); setPrivateSign(${idx}, '${card.token}', '+')">+</button>
                                <button class="sign-btn ${state.selectedPrivate === idx && state.selectedPrivateSign === '-' ? 'active' : ''}"
                                        onclick="event.stopPropagation(); setPrivateSign(${idx}, '${card.token}', '-')">−</button>
                            </div>
                        </div>
                    `;
                }).join('');

                // Store private cards in state
                state.privateCards = privateCards;
            } catch (error) {
                console.error('Error fetching private cards:', error);
                const privateContainer = document.getElementById('private-cards');
                privateContainer.innerHTML = `
                    <div class="status-message status-error">
                        Error loading private cards. Please refresh.
                    </div>
                `;
            }
        }

        function selectPublicCard(idx, token) {
            state.selectedPublic = idx;
            updateCardSelection();
        }

        function setPublicSign(idx, token, sign) {
            state.selectedPublic = idx;
            state.selectedPublicSign = sign;
            updateCardSelection();
        }

        function selectPrivateCard(idx, token) {
            state.selectedPrivate = idx;
            updateCardSelection();
        }

        function setPrivateSign(idx, token, sign) {
            state.selectedPrivate = idx;
            state.selectedPrivateSign = sign;
            updateCardSelection();
        }

        function updateCardSelection() {
            // Update visual selection
            document.querySelectorAll('#public-cards .card').forEach((card, idx) => {
                if (idx === state.selectedPublic) {
                    card.classList.add('selected');
                } else {
                    card.classList.remove('selected');
                }
            });

            document.querySelectorAll('#private-cards .card').forEach((card, idx) => {
                if (idx === state.selectedPrivate) {
                    card.classList.add('selected');
                } else {
                    card.classList.remove('selected');
                }
            });

            // Enable submit button if both cards selected
            const submitBtn = document.getElementById('submit-btn');
            if (submitBtn && state.selectedPublic !== null && state.selectedPrivate !== null) {
                submitBtn.disabled = false;
                submitBtn.textContent = `Submit Move (${state.selectedPublicSign}public, ${state.selectedPrivateSign}private)`;
            } else if (submitBtn) {
                submitBtn.disabled = true;
                submitBtn.textContent = 'Select 2 cards to submit';
            }
        }

        function startTimer(deadline) {
            if (state.timerInterval) {
                clearInterval(state.timerInterval);
            }

            const updateTimer = () => {
                const now = Math.floor(Date.now() / 1000);
                const remaining = deadline - now;

                if (remaining <= 0) {
                    document.getElementById('timer').textContent = 'Time: 00:00';
                    clearInterval(state.timerInterval);
                    return;
                }

                const minutes = Math.floor(remaining / 60);
                const seconds = remaining % 60;
                document.getElementById('timer').textContent =
                    `Time: ${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            };

            updateTimer();
            state.timerInterval = setInterval(updateTimer, 1000);
        }

        async function submitMove() {
            if (state.selectedPublic === null) {
                alert('Please select a public card');
                return;
            }

            if (state.selectedPrivate === null) {
                alert('Please select a private card');
                return;
            }

            const publicToken = state.currentRound.public_cards[state.selectedPublic].token;
            const privateCard = state.privateCards[state.selectedPrivate];

            let privateToken = privateCard.token;
            let jokerOverride = null;

            // Handle JOKER card
            if (privateCard.type === 'JOKER') {
                const jokerInput = document.getElementById(`joker-input-${state.selectedPrivate}`);
                jokerOverride = jokerInput ? jokerInput.value.trim() : null;

                if (!jokerOverride) {
                    alert('Please enter a word for your JOKER card');
                    return;
                }
            }

            try {
                const response = await fetch(
                    `${API_URL}/match/${state.matchId}/round/${state.roundId}/submit`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            player_id: state.playerId,
                            public_token: publicToken,
                            public_sign: state.selectedPublicSign,
                            private_token: privateToken,
                            private_sign: state.selectedPrivateSign,
                            joker_override_token: jokerOverride
                        })
                    }
                );

                if (!response.ok) {
                    const error = await response.json();
                    alert(`Error: ${error.detail}`);
                    return;
                }

                const result = await response.json();

                // Show real-time feedback
                const feedbackDiv = document.getElementById('nearest-word-feedback');
                feedbackDiv.style.display = 'block';
                document.getElementById('nearest-word-display').textContent = result.nearest;
                document.getElementById('target-similarity-display').textContent = result.similarity.toFixed(4);
                document.getElementById('nearest-similarity-display').textContent = result.nearest_sim.toFixed(4);

                document.getElementById('submit-btn').disabled = true;
                document.getElementById('submit-btn').textContent = 'Move Submitted - Waiting for others...';
            } catch (error) {
                alert(`Error: ${error.message}`);
            }
        }

        async function refreshRound() {
            try {
                const response = await fetch(`${API_URL}/match/${state.matchId}/round/current`);
                const roundData = await response.json();

                // Check if we can resolve
                const resolveBtn = document.createElement('button');
                resolveBtn.textContent = 'View Results';
                resolveBtn.onclick = viewResults;
                resolveBtn.className = 'btn-secondary';
                resolveBtn.style.marginTop = '10px';

                if (!document.querySelector('button[onclick="viewResults()"]')) {
                    document.getElementById('game-screen').appendChild(resolveBtn);
                }
            } catch (error) {
                console.error('Error refreshing round:', error);
            }
        }

        async function viewResults() {
            try {
                const response = await fetch(
                    `${API_URL}/match/${state.matchId}/round/${state.roundId}/resolve`,
                    { method: 'POST' }
                );

                if (!response.ok) {
                    const error = await response.json();
                    alert(`Error: ${error.detail}`);
                    return;
                }

                const data = await response.json();
                displayResults(data.leaderboard);
            } catch (error) {
                alert(`Error: ${error.message}`);
            }
        }

        function displayResults(leaderboard) {
            // Store results in state for visualization
            state.lastRoundResults = {
                leaderboard: leaderboard,
                startWord: state.currentRound.start_word,
                targetWord: state.currentRound.target_word
            };

            document.getElementById('results-start-word').textContent =
                state.currentRound.start_word;
            document.getElementById('results-target-word').textContent =
                state.currentRound.target_word;

            const tbody = document.getElementById('leaderboard-body');
            tbody.innerHTML = leaderboard.map((entry, idx) => {
                const badge = getSimilarityBadge(entry.similarity);
                const nearestSim = entry.nearest_sim || 0;
                return `
                    <tr class="${idx === 0 ? 'rank-1' : ''}">
                        <td>${idx + 1}</td>
                        <td>${entry.player_name}</td>
                        <td>${entry.similarity.toFixed(4)}</td>
                        <td>
                            <strong style="color: #667eea; font-size: 1.1em;">${entry.nearest}</strong>
                            <div style="font-size: 0.85em; color: #999; margin-top: 2px;">
                                similarity: ${nearestSim.toFixed(4)}
                            </div>
                        </td>
                        <td><span class="similarity-badge ${badge.class}">${badge.label}</span></td>
                    </tr>
                `;
            }).join('');

            showScreen('results-screen');

            if (state.timerInterval) {
                clearInterval(state.timerInterval);
            }
        }

        function getSimilarityBadge(sim) {
            if (sim >= 0.80) return { class: 'sim-very-close', label: 'Very Close' };
            if (sim >= 0.60) return { class: 'sim-warm', label: 'Getting Warmer' };
            if (sim >= 0.40) return { class: 'sim-lukewarm', label: 'Lukewarm' };
            if (sim >= 0.20) return { class: 'sim-cold', label: 'Cold' };
            return { class: 'sim-ice-cold', label: 'Ice Cold' };
        }

        async function nextRound() {
            try {
                const response = await fetch(
                    `${API_URL}/match/${state.matchId}/round/next`,
                    { method: 'POST' }
                );

                if (!response.ok) {
                    const error = await response.json();
                    alert(`Error: ${error.detail}`);
                    return;
                }

                const roundData = await response.json();
                state.roundId = roundData.id;
                state.currentRound = roundData;
                state.selectedPublic = null;
                state.selectedPrivate = null;
                state.selectedPublicSign = '+';
                state.selectedPrivateSign = '+';
                state.jokerToken = null;

                document.getElementById('submit-btn').disabled = false;
                document.getElementById('submit-btn').textContent = 'Submit Move';

                displayRound(roundData);
                showScreen('game-screen');
            } catch (error) {
                alert(`Error: ${error.message}`);
            }
        }

        function copyShareLink() {
            if (!state.matchId) {
                alert('No active match');
                return;
            }

            const shareUrl = `${window.location.origin}${window.location.pathname}?match=${state.matchId}`;

            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(shareUrl).then(() => {
                    alert(`✅ Link copied to clipboard!\n\n${shareUrl}\n\nShare this with friends to join the match.`);
                }).catch(() => {
                    alert(`📋 Copy this link to share:\n\n${shareUrl}`);
                });
            } else {
                // Fallback for non-secure contexts
                const textArea = document.createElement('textarea');
                textArea.value = shareUrl;
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    alert(`✅ Link copied!\n\n${shareUrl}`);
                } catch (err) {
                    alert(`📋 Copy this link to share:\n\n${shareUrl}`);
                }
                document.body.removeChild(textArea);
            }
        }

        // ============================================
        // Visualization Functions
        // ============================================

        async function visualizeRound() {
            try {
                // Get current round data from state
                const startWord = document.getElementById('results-start-word').textContent;
                const targetWord = document.getElementById('results-target-word').textContent;

                // Get the winning player's move (first in leaderboard)
                const leaderboard = state.lastRoundResults?.leaderboard;
                if (!leaderboard || leaderboard.length === 0) {
                    alert('No round results available to visualize');
                    return;
                }

                const bestMove = leaderboard[0];
                const publicWord = bestMove.public_token;
                const privateWord = bestMove.private_token;
                const publicSign = bestMove.public_sign === 1 ? '+' : '-';
                const privateSign = bestMove.private_sign === 1 ? '+' : '-';
                const nearestWord = bestMove.nearest;

                // Fetch visualization data
                const url = `${API_URL}/visualize/move/${startWord}/${targetWord}?` +
                           `public_word=${publicWord}&private_word=${privateWord}&` +
                           `public_sign=${publicSign}&private_sign=${privateSign}`;

                const resp = await fetch(url);
                const data = await resp.json();

                // Fetch nearest word coordinates separately if not in original data
                const nearestUrl = `${API_URL}/visualize/move/${startWord}/${targetWord}?` +
                                  `public_word=${nearestWord}&private_word=&` +
                                  `public_sign=&private_sign=`;

                try {
                    const nearestResp = await fetch(nearestUrl);
                    const nearestData = await nearestResp.json();
                    // Find the point that matches the nearest word
                    const nearestPoint = nearestData.points.find(p =>
                        p.word.toLowerCase() === nearestWord.toLowerCase()
                    );
                    if (nearestPoint) {
                        // Add nearest word to visualization points
                        nearestPoint.word = `${nearestWord} (nearest)`;
                        nearestPoint.isNearest = true;
                        data.points.push(nearestPoint);
                    }
                } catch (e) {
                    console.warn('Could not fetch nearest word coordinates:', e);
                }

                // Render visualization
                renderVisualization(data.points, nearestWord);

                // Show modal
                document.getElementById('viz-modal').classList.add('active');

            } catch (error) {
                console.error('Visualization error:', error);
                alert('Failed to load visualization. Make sure the round has completed.');
            }
        }

        function closeVisualization() {
            document.getElementById('viz-modal').classList.remove('active');
        }

        function renderVisualization(points, nearestWord) {
            const canvas = document.getElementById('viz-canvas');
            const ctx = canvas.getContext('2d');

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Find min/max for scaling
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;

            points.forEach(p => {
                minX = Math.min(minX, p.x);
                maxX = Math.max(maxX, p.x);
                minY = Math.min(minY, p.y);
                maxY = Math.max(maxY, p.y);
            });

            // Add padding
            const padding = 60;
            const width = canvas.width - 2 * padding;
            const height = canvas.height - 2 * padding;

            // Scale function
            const scaleX = (x) => padding + ((x - minX) / (maxX - minX)) * width;
            const scaleY = (y) => padding + ((y - minY) / (maxY - minY)) * height;

            // Draw grid
            ctx.strokeStyle = '#f0f0f0';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const x = padding + (i / 10) * width;
                const y = padding + (i / 10) * height;
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, padding + height);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(padding + width, y);
                ctx.stroke();
            }

            // Define colors for different word types
            const colorMap = {
                'RESULT': '#2ecc71',
                'default': '#999'
            };

            // Draw lines from start to other points
            const startPoint = points.find(p => p.word.toLowerCase() === points[0].word.toLowerCase());
            if (startPoint) {
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 1;
                points.forEach(p => {
                    if (p !== startPoint) {
                        ctx.beginPath();
                        ctx.moveTo(scaleX(startPoint.x), scaleY(startPoint.y));
                        ctx.lineTo(scaleX(p.x), scaleY(p.y));
                        ctx.stroke();
                    }
                });
            }

            // Draw points
            points.forEach((p, idx) => {
                const x = scaleX(p.x);
                const y = scaleY(p.y);

                // Determine color and style based on word type
                let color, radius = 8, strokeWidth = 2, strokeColor = '#fff';

                if (p.isNearest) {
                    // Nearest word - special highlighting
                    color = '#f6d365';
                    radius = 10;
                    strokeWidth = 3;
                    strokeColor = '#fda085';
                } else if (idx === 0) {
                    color = '#667eea'; // Start word
                } else if (idx === 1) {
                    color = '#e74c3c'; // Target word
                } else if (p.word === 'RESULT') {
                    color = '#2ecc71'; // Result vector
                } else if (idx === 2) {
                    color = '#f39c12'; // Public card
                } else if (idx === 3) {
                    color = '#9b59b6'; // Private card
                } else {
                    color = '#999'; // Other
                }

                // Draw circle
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.fillStyle = color;
                ctx.fill();
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = strokeWidth;
                ctx.stroke();

                // Draw label
                ctx.fillStyle = p.isNearest ? '#f6d365' : '#333';
                ctx.font = p.isNearest ? 'bold 14px sans-serif' : 'bold 12px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText(p.word, x, y - 12 - (p.isNearest ? 2 : 0));
            });

            // Draw axes labels
            ctx.fillStyle = '#666';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Dimension 1 (PCA)', canvas.width / 2, canvas.height - 10);
            ctx.save();
            ctx.translate(15, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Dimension 2 (PCA)', 0, 0);
            ctx.restore();
        }

        // ============================================
        // Puzzle Mode Functions
        // ============================================

        async function showPuzzleMode() {
            try {
                const resp = await fetch(`${API_URL}/puzzles`);
                const puzzles = await resp.json();
                state.allPuzzles = puzzles;
                renderPuzzleList(puzzles);
                showScreen('puzzle-select-screen');
            } catch (error) {
                console.error('Error loading puzzles:', error);
                alert('Failed to load puzzles. Please try again.');
            }
        }

        function renderPuzzleList(puzzles) {
            const container = document.getElementById('puzzle-list');
            container.innerHTML = puzzles.map(p => `
                <div style="background: white; border: 2px solid #e0e0e0; border-radius: 12px; padding: 20px; margin-bottom: 15px; cursor: pointer; transition: all 0.3s;"
                     onmouseover="this.style.borderColor='#667eea'; this.style.transform='translateY(-2px)'"
                     onmouseout="this.style.borderColor='#e0e0e0'; this.style.transform='translateY(0)'"
                     onclick="loadPuzzle(${p.id})">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <strong style="font-size: 1.1em; color: #333;">${p.name}</strong>
                        <span style="padding: 4px 12px; border-radius: 20px; font-size: 0.85em; font-weight: 600;
                            ${p.difficulty === 'easy' ? 'background: #4caf50; color: white;' :
                              p.difficulty === 'medium' ? 'background: #ff9800; color: white;' :
                              'background: #f44336; color: white;'}">
                            ${p.difficulty.toUpperCase()}
                        </span>
                    </div>
                    <div style="color: #666; margin-bottom: 8px;">${p.description}</div>
                    <div style="font-size: 0.9em; color: #999;">
                        <strong style="color: #667eea;">${p.start_word}</strong> →
                        <strong style="color: #e74c3c;">${p.target_word}</strong>
                    </div>
                </div>
            `).join('');
        }

        async function filterPuzzles() {
            const difficulty = document.getElementById('puzzle-difficulty-filter').value;
            let filtered = state.allPuzzles;
            if (difficulty) {
                filtered = state.allPuzzles.filter(p => p.difficulty === difficulty);
            }
            renderPuzzleList(filtered);
        }

        async function loadPuzzle(puzzleId) {
            try {
                const resp = await fetch(`${API_URL}/puzzle/${puzzleId}`);
                const puzzle = await resp.json();
                state.currentPuzzle = puzzle;
                state.puzzleSelectedCards = { public: null, private: null };

                // Display puzzle info
                document.getElementById('puzzle-name').textContent = puzzle.name;
                document.getElementById('puzzle-description').textContent = puzzle.description;
                document.getElementById('puzzle-difficulty-badge').innerHTML = `
                    <span style="padding: 4px 12px; border-radius: 20px; font-size: 0.85em; font-weight: 600;
                        ${puzzle.difficulty === 'easy' ? 'background: #4caf50; color: white;' :
                          puzzle.difficulty === 'medium' ? 'background: #ff9800; color: white;' :
                          'background: #f44336; color: white;'}">
                        ${puzzle.difficulty.toUpperCase()}
                    </span>
                `;
                document.getElementById('puzzle-start-word').textContent = puzzle.start_word;
                document.getElementById('puzzle-target-word').textContent = puzzle.target_word;
                document.getElementById('hint-display').textContent = '';

                // Show wildcard indicator if available
                if (puzzle.has_wildcard) {
                    const wildcardNote = document.createElement('div');
                    wildcardNote.style.cssText = 'background: #fff3cd; padding: 12px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #ffc107; color: #856404;';
                    wildcardNote.innerHTML = '<strong>🃏 WILDCARD PUZZLE!</strong> You can use ANY word from the vocabulary, not just the cards shown below!';
                    document.getElementById('puzzle-cards').parentElement.insertBefore(wildcardNote, document.getElementById('puzzle-cards'));
                }

                // Render cards
                const cardsContainer = document.getElementById('puzzle-cards');
                cardsContainer.innerHTML = puzzle.allowed_cards.map(card => `
                    <div class="card" onclick="selectPuzzleCard('${card}')" id="puzzle-card-${card}">
                        <div class="card-token">${card}</div>
                        <div class="card-controls">
                            <button class="sign-btn active" data-sign="+" onclick="event.stopPropagation(); togglePuzzleSign('${card}', '+')">+</button>
                            <button class="sign-btn" data-sign="-" onclick="event.stopPropagation(); togglePuzzleSign('${card}', '-')">
                                <span style="font-size: 1.2em;">−</span> SUBTRACT
                            </button>
                        </div>
                    </div>
                `).join('');

                showScreen('puzzle-play-screen');
            } catch (error) {
                console.error('Error loading puzzle:', error);
                alert('Failed to load puzzle. Please try again.');
            }
        }

        function selectPuzzleCard(card) {
            const cardElement = document.getElementById(`puzzle-card-${card}`);

            // If clicking already selected card, deselect it
            if (state.puzzleSelectedCards.public === card) {
                state.puzzleSelectedCards.public = null;
                cardElement.classList.remove('selected', 'selected-minus');
                return;
            }
            if (state.puzzleSelectedCards.private === card) {
                state.puzzleSelectedCards.private = null;
                cardElement.classList.remove('selected', 'selected-minus');
                return;
            }

            // Select card
            if (!state.puzzleSelectedCards.public) {
                // Deselect previous public if any
                const prevPublic = document.querySelector('#puzzle-cards .card.selected');
                if (prevPublic) prevPublic.classList.remove('selected', 'selected-minus');

                state.puzzleSelectedCards.public = card;
                cardElement.classList.add('selected');
                updateCardHighlight(card);
            } else if (!state.puzzleSelectedCards.private) {
                state.puzzleSelectedCards.private = card;
                cardElement.classList.add('selected');
                updateCardHighlight(card);
            } else {
                alert('You can only select two cards. Deselect one first.');
            }
        }

        function togglePuzzleSign(card, sign) {
            const cardElement = document.getElementById(`puzzle-card-${card}`);

            // First, select the card if it's not already selected
            if (state.puzzleSelectedCards.public !== card && state.puzzleSelectedCards.private !== card) {
                selectPuzzleCard(card);
            }

            // Then toggle the sign buttons
            const buttons = document.querySelectorAll(`#puzzle-card-${card} .sign-btn`);
            buttons.forEach(btn => {
                const btnSign = btn.getAttribute('data-sign');
                if (btnSign === sign) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            // Update card highlight based on sign
            updateCardHighlight(card);
        }

        function updateCardHighlight(card) {
            const cardElement = document.getElementById(`puzzle-card-${card}`);
            if (!cardElement) return;

            // Check if this card has minus selected
            const minusBtn = cardElement.querySelector('.sign-btn[data-sign="-"]');
            const hasMinusActive = minusBtn && minusBtn.classList.contains('active');

            // Update card appearance
            if (hasMinusActive) {
                cardElement.classList.remove('selected');
                cardElement.classList.add('selected-minus');
            } else {
                cardElement.classList.remove('selected-minus');
                if (cardElement.classList.contains('selected') ||
                    state.puzzleSelectedCards.public === card ||
                    state.puzzleSelectedCards.private === card) {
                    cardElement.classList.add('selected');
                }
            }
        }

        function showHint() {
            if (state.currentPuzzle && state.currentPuzzle.hint) {
                document.getElementById('hint-display').textContent = state.currentPuzzle.hint;
            }
        }

        async function submitPuzzleSolution() {
            if (!state.puzzleSelectedCards.public || !state.puzzleSelectedCards.private) {
                alert('Please select exactly two cards');
                return;
            }

            try {
                // Get signs from buttons
                const publicCard = state.puzzleSelectedCards.public;
                const privateCard = state.puzzleSelectedCards.private;

                const publicSignBtn = document.querySelector(`#puzzle-card-${publicCard} .sign-btn.active`);
                const privateSignBtn = document.querySelector(`#puzzle-card-${privateCard} .sign-btn.active`);

                const publicSign = publicSignBtn?.textContent.trim() === '+' ? 1 : -1;
                const privateSign = privateSignBtn?.textContent.trim() === '+' ? 1 : -1;

                const solution = {
                    public_token: publicCard,
                    public_sign: publicSign,
                    private_token: privateCard,
                    private_sign: privateSign
                };

                const resp = await fetch(`${API_URL}/puzzle/${state.currentPuzzle.id}/solve`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(solution)
                });

                const result = await resp.json();

                if (!result.valid) {
                    alert(result.error || 'Invalid solution');
                    return;
                }

                // Display results
                const starsHTML = '⭐'.repeat(result.stars) + '☆'.repeat(3 - result.stars);
                document.getElementById('stars-display').textContent = starsHTML;
                document.getElementById('puzzle-result-similarity').textContent = result.similarity.toFixed(4);
                document.getElementById('puzzle-result-nearest').textContent = result.nearest_word;

                document.getElementById('puzzle-result-start').textContent = state.currentPuzzle.start_word;
                document.getElementById('puzzle-result-target').textContent = state.currentPuzzle.target_word;
                document.getElementById('puzzle-result-public-sign').textContent = result.public_sign;
                document.getElementById('puzzle-result-public').textContent = result.public_used;
                document.getElementById('puzzle-result-private-sign').textContent = result.private_sign;
                document.getElementById('puzzle-result-private').textContent = result.private_used;

                // Display best move
                if (result.best_move) {
                    const bestMoveHTML = `
                        <div style="background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.1);">
                            <div style="margin-bottom: 8px;">
                                <strong>${state.currentPuzzle.start_word}</strong>
                            </div>
                            <div style="margin: 10px 0 10px 20px;">
                                ${result.best_move.public_sign} <strong>${result.best_move.public_card}</strong><br>
                                ${result.best_move.private_sign} <strong>${result.best_move.private_card}</strong>
                            </div>
                            <div>
                                → <strong>${state.currentPuzzle.target_word}</strong>
                            </div>
                            <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #e0e0e0; color: #2e7d32; font-weight: 600;">
                                Similarity: ${result.best_move.similarity}
                            </div>
                        </div>
                    `;
                    document.getElementById('best-move-content').innerHTML = bestMoveHTML;
                }

                // Display all moves with highlighting of player's move
                if (result.all_moves && result.all_moves.length > 0) {
                    const playerMove = `${result.public_sign}${result.public_used},${result.private_sign}${result.private_used}`;

                    const movesHTML = result.all_moves.map((move, index) => {
                        const moveKey = `${move.public_sign}${move.public_card},${move.private_sign}${move.private_card}`;
                        const isPlayerMove = moveKey === playerMove;

                        return `
                            <div style="
                                display: flex;
                                justify-content: space-between;
                                align-items: center;
                                padding: 10px 15px;
                                margin: 5px 0;
                                background: ${isPlayerMove ? '#fff3cd' : 'white'};
                                border-radius: 6px;
                                border: ${isPlayerMove ? '2px solid #ffc107' : '1px solid #e0e0e0'};
                                font-size: 0.9em;
                            ">
                                <div style="flex: 1;">
                                    <span style="color: #999; font-size: 0.85em; margin-right: 10px;">#${index + 1}</span>
                                    <span style="font-family: monospace;">
                                        ${move.public_sign} <strong>${move.public_card}</strong>,
                                        ${move.private_sign} <strong>${move.private_card}</strong>
                                    </span>
                                    ${isPlayerMove ? '<span style="margin-left: 8px; color: #f59e0b; font-weight: 600;">← You</span>' : ''}
                                </div>
                                <div style="
                                    font-weight: 600;
                                    color: ${move.similarity >= 0.7 ? '#2e7d32' : move.similarity >= 0.5 ? '#f57c00' : '#d32f2f'};
                                    min-width: 60px;
                                    text-align: right;
                                ">
                                    ${move.similarity}
                                </div>
                            </div>
                        `;
                    }).join('');

                    document.getElementById('all-moves-content').innerHTML = movesHTML;
                }

                // Render 2D visualization
                await renderVisualization(result);

                showScreen('puzzle-result-screen');
            } catch (error) {
                console.error('Error submitting solution:', error);
                alert('Failed to submit solution. Please try again.');
            }
        }

        async function renderVisualization(puzzleResult) {
            try {
                // Collect all words to visualize
                const words = [...state.currentPuzzle.allowed_cards];

                // Get the move details
                const publicSign = puzzleResult.public_sign === '+' ? 1 : -1;
                const privateSign = puzzleResult.private_sign === '+' ? 1 : -1;

                const vizRequest = {
                    words: words,
                    start_word: state.currentPuzzle.start_word,
                    target_word: state.currentPuzzle.target_word,
                    result_word: puzzleResult.nearest_word,
                    public_card: puzzleResult.public_used,
                    public_sign: publicSign,
                    private_card: puzzleResult.private_used,
                    private_sign: privateSign
                };

                console.log('Fetching visualization...', vizRequest);
                const resp = await fetch(`${API_URL}/visualize`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(vizRequest)
                });

                if (!resp.ok) {
                    throw new Error(`Visualization API error: ${resp.status}`);
                }

                const vizData = await resp.json();
                console.log('Visualization data received:', vizData);

                // Draw on canvas
                const canvas = document.getElementById('word-viz-canvas');
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;

                // Clear canvas
                ctx.clearRect(0, 0, width, height);

                // Add padding
                const padding = 40;
                const plotWidth = width - 2 * padding;
                const plotHeight = height - 2 * padding;

                // Draw each point
                vizData.points.forEach(point => {
                    const x = padding + point.x * plotWidth;
                    const y = padding + (1 - point.y) * plotHeight; // Flip Y axis

                    // Set color and size based on type
                    let color, radius, label;
                    switch (point.type) {
                        case 'start':
                            color = '#4caf50'; // Green
                            radius = 10;
                            label = true;
                            break;
                        case 'target':
                            color = '#f44336'; // Red
                            radius = 10;
                            label = true;
                            break;
                        case 'result':
                            color = '#ffc107'; // Yellow/Amber
                            radius = 8;
                            label = true;
                            break;
                        case 'step1':
                            color = '#6A1B9A'; // Dark Purple/Magenta - intermediate step 1 (better contrast)
                            radius = 9;
                            label = true;
                            break;
                        case 'step2':
                            color = '#EF6C00'; // Dark Orange - intermediate step 2 (better contrast)
                            radius = 9;
                            label = true;
                            break;
                        default:
                            color = '#9e9e9e'; // Gray
                            radius = 5;
                            label = false;
                    }

                    // Draw point
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, 2 * Math.PI);
                    ctx.fillStyle = color;
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Draw label for special points
                    if (label) {
                        ctx.fillStyle = '#2d3748';
                        ctx.font = 'bold 12px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText(point.word, x, y - radius - 5);
                    }

                    // Draw small labels for cards
                    if (!label && point.type === 'card') {
                        ctx.fillStyle = '#666';
                        ctx.font = '9px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText(point.word, x, y + radius + 10);
                    }
                });

                // Draw path showing each step
                const startPoint = vizData.points.find(p => p.type === 'start');
                const step1Point = vizData.points.find(p => p.type === 'step1');
                const step2Point = vizData.points.find(p => p.type === 'step2');
                const resultPoint = vizData.points.find(p => p.type === 'result');
                const targetPoint = vizData.points.find(p => p.type === 'target');

                // Also get the card positions for visualization
                const publicCardPoint = vizData.points.find(p => p.word === puzzleResult.public_used);
                const privateCardPoint = vizData.points.find(p => p.word === puzzleResult.private_used);

                // Helper function to draw arrow with card highlight
                function drawArrow(fromX, fromY, toX, toY, color, label, cardPoint) {
                    ctx.save();

                    // If we have a card point, draw a line through it to show how it affects the path
                    if (cardPoint) {
                        const cardX = padding + cardPoint.x * plotWidth;
                        const cardY = padding + (1 - cardPoint.y) * plotHeight;

                        // Highlight the card being used
                        ctx.beginPath();
                        ctx.arc(cardX, cardY, 8, 0, 2 * Math.PI);
                        ctx.fillStyle = color;
                        ctx.fill();
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 3;
                        ctx.stroke();

                        // Draw label near card
                        ctx.fillStyle = '#fff';
                        ctx.strokeStyle = color;
                        ctx.lineWidth = 3;
                        ctx.font = 'bold 11px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.strokeText(cardPoint.word, cardX, cardY - 15);
                        ctx.fillText(cardPoint.word, cardX, cardY - 15);
                    }

                    ctx.restore();
                }

                // Original arrow drawing function
                function drawPathArrow(fromX, fromY, toX, toY, color, label) {
                    ctx.save();
                    ctx.strokeStyle = color;
                    ctx.fillStyle = color;
                    ctx.lineWidth = 3;

                    // Draw line
                    ctx.beginPath();
                    ctx.moveTo(fromX, fromY);
                    ctx.lineTo(toX, toY);
                    ctx.stroke();

                    // Draw arrowhead
                    const angle = Math.atan2(toY - fromY, toX - fromX);
                    const headlen = 10;
                    ctx.beginPath();
                    ctx.moveTo(toX, toY);
                    ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
                    ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
                    ctx.closePath();
                    ctx.fill();

                    // Draw label at midpoint
                    if (label) {
                        const midX = (fromX + toX) / 2;
                        const midY = (fromY + toY) / 2;
                        ctx.fillStyle = '#fff';
                        ctx.strokeStyle = color;
                        ctx.lineWidth = 3;
                        ctx.font = 'bold 11px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.strokeText(label, midX, midY - 5);
                        ctx.fillText(label, midX, midY - 5);
                    }

                    ctx.restore();
                }

                // Highlight the cards being used first
                if (publicCardPoint) {
                    drawArrow(null, null, null, null, '#6A1B9A',
                             puzzleResult.public_sign + ' ' + puzzleResult.public_used,
                             publicCardPoint);
                }
                if (privateCardPoint) {
                    drawArrow(null, null, null, null, '#EF6C00',
                             puzzleResult.private_sign + ' ' + puzzleResult.private_used,
                             privateCardPoint);
                }

                // Draw path: start → step1 → step2 → target
                if (startPoint && step1Point) {
                    drawPathArrow(
                        padding + startPoint.x * plotWidth,
                        padding + (1 - startPoint.y) * plotHeight,
                        padding + step1Point.x * plotWidth,
                        padding + (1 - step1Point.y) * plotHeight,
                        '#6A1B9A',
                        'Step 1'
                    );
                }

                if (step1Point && step2Point) {
                    drawPathArrow(
                        padding + step1Point.x * plotWidth,
                        padding + (1 - step1Point.y) * plotHeight,
                        padding + step2Point.x * plotWidth,
                        padding + (1 - step2Point.y) * plotHeight,
                        '#EF6C00',
                        'Step 2'
                    );
                }

                // Draw dotted line to target showing distance remaining
                const lastStep = step2Point || step1Point || startPoint;
                if (lastStep && targetPoint) {
                    ctx.save();
                    ctx.strokeStyle = '#f44336';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(padding + lastStep.x * plotWidth, padding + (1 - lastStep.y) * plotHeight);
                    ctx.lineTo(padding + targetPoint.x * plotWidth, padding + (1 - targetPoint.y) * plotHeight);
                    ctx.stroke();
                    ctx.restore();
                }

                // Generate natural language explanation
                const explDiv = document.getElementById('explanation-text');
                console.log('Explanation div:', explDiv);
                if (explDiv) {
                    const publicOp = puzzleResult.public_sign === '+' ? 'added' : 'subtracted';
                    const privateOp = puzzleResult.private_sign === '+' ? 'added' : 'subtracted';

                    let explanation = `<p><strong>Your strategy:</strong> Starting from "<em>${state.currentPuzzle.start_word}</em>", you ${publicOp} the concept of "<em>${puzzleResult.public_used}</em>" and then ${privateOp} "<em>${puzzleResult.private_used}</em>".</p>`;

                    explanation += `<p><strong>Step 1:</strong> ${puzzleResult.public_sign === '+' ? 'Adding' : 'Subtracting'} "${puzzleResult.public_used}" shifted your position in semantic space`;
                    if (step1Point) {
                        explanation += ` toward concepts related to ${puzzleResult.public_used}.`;
                    }
                    explanation += `</p>`;

                    explanation += `<p><strong>Step 2:</strong> Then ${puzzleResult.private_sign === '+' ? 'adding' : 'subtracting'} "${puzzleResult.private_used}" moved you further`;
                    if (step2Point) {
                        explanation += `, bringing you closer to the target.`;
                    }
                    explanation += `</p>`;

                    explanation += `<p><strong>Result:</strong> Your combined move landed you at "<em>${puzzleResult.nearest_word}</em>", with a similarity of ${puzzleResult.similarity.toFixed(3)} to the target "<em>${state.currentPuzzle.target_word}</em>".</p>`;

                    // Add optimal move explanation if available
                    if (puzzleResult.best_move) {
                        const bestSim = puzzleResult.best_move.similarity;
                        if (Math.abs(bestSim - puzzleResult.similarity) > 0.01) {
                            explanation += `<p style="background: #f0f4ff; padding: 10px; border-radius: 6px; margin-top: 10px;"><strong>💡 Optimal strategy:</strong> The best move was to ${puzzleResult.best_move.public_sign === '+' ? 'add' : 'subtract'} "${puzzleResult.best_move.public_card}" and ${puzzleResult.best_move.private_sign === '+' ? 'add' : 'subtract'} "${puzzleResult.best_move.private_card}", reaching a similarity of ${bestSim.toFixed(3)}.</p>`;
                        } else {
                            explanation += `<p style="background: #e8f5e9; padding: 10px; border-radius: 6px; margin-top: 10px;"><strong>🎯 Perfect!</strong> You found the optimal solution!</p>`;
                        }
                    }

                    explDiv.innerHTML = explanation;
                }

            } catch (error) {
                console.error('Error rendering visualization:', error);
                // Don't show error to user, visualization is optional
            }
        }

        function nextPuzzle() {
            // Find next puzzle
            const currentIdx = state.allPuzzles.findIndex(p => p.id === state.currentPuzzle.id);
            if (currentIdx < state.allPuzzles.length - 1) {
                loadPuzzle(state.allPuzzles[currentIdx + 1].id);
            } else {
                alert('You completed all puzzles! 🎉');
                showScreen('puzzle-select-screen');
            }
        }

        // Auto-refresh lobby every 3 seconds when waiting
        setInterval(() => {
            if (document.getElementById('waiting-screen').classList.contains('active')) {
                refreshLobby();
            }
        }, 3000);
    </script>
</body>
</html>
